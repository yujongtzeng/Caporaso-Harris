import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;
import java.math.BigInteger; 

/**
 * <p>
 * Let N(d, r, alpha, beta) be the number of r-nodal degree d curves on
 * P^2 which satisfy tangency conditions (alpha, beta) with a fixed 
 * line. 
 * CHdecreaseCheck is a program which checks that for fixed d, r, beta, 
 * whether N(d, r, alpha, beta) is a non-increasing sequence in lexicographic 
 * order of alpha. 
 * If not, the counterexample will be printed out on the screen as
 * "N(d, r, alpha, beta) > last" where last is the number right before. 
 * </p>
 * 
 * deg: the maximal degrees of the curve <br>
 * maxNode:  max difference between the arithmetic genus and geometric genus of 
 * the curve the program will compute.  <br>
 * 
 * The program will check N(d, r, alpha, beta) for all d <= deg, 
 * 0 <= r <= maxNode, and all valid alpha and beta. 
 * 
 * @author Yu-jong Tzeng
 * @version 4.0
 * @since 2.0.
 */
public class CHdecreaseCheck {
    private static int deg;
    private static int maxNode;
    private static ArrayOp arrOp;  
    private Partitions parArr; 
    private HashMap<ArrayList<Byte>, BigInteger> prevMap;
    private HashMap<ArrayList<Byte>, BigInteger> curMap;    

    /**
    * The constructor of the class.
    * @param deg The maximal degree of the curves. 
    * @param maxNode The maximal number of nodes of the curves.
    */
    public CHdecreaseCheck (int deg, int maxNode) {
        this.deg = deg;
        this.maxNode = maxNode;           
        arrOp = new ArrayOp(deg);      
        parArr = new Partitions(deg);
        prevMap = new HashMap<ArrayList<Byte>, BigInteger>();
        curMap = new HashMap<ArrayList<Byte>, BigInteger>();
    }    
    /** 
     * The main method of the class.
     * Paramaters deg and maxNode are initialzed by user input. Then the 
     * program will compute CH invariants and generate output. 
     * @param args Unused
     */
    public static void main(String[] args) {
        Scanner reader = new Scanner(System.in);  // Reading from System.in
        System.out.println("This program will check whether the number of" 
                    + "nodal curves on the projective plane of fixed ");
        System.out.println("degree and nodes and beta is non-increasing" 
            + "in lexicographic order of alpha.");
        System.out.println("Enter the max degree of the curve:");        
        System.out.println("degree = ");
        int inputdeg = reader.nextInt();
        System.out.println("Enter the max number of nodes:");        
        System.out.println("maxNode = ");
        int inputMaxNode = reader.nextInt();        
        System.out.println("If not, the increasing part will be printed out.");
        reader.close();
                 
        CHdecreaseCheck check = new CHdecreaseCheck(inputdeg, inputMaxNode);
        check.compute();
    }    
    /** 
     * Put N(O(d), r, alpha and beta) into dictionary 
     * for given d, r = 0,...,maxNode and all valid alpha and beta.
     * If d >= deg - printLast, write the result in the output file. 
     */
    private void compute() {    
        for (int d = 1; d <= deg; d++) {
            System.out.println("Checking: d = " + d);
            prevMap = curMap;
            curMap = new HashMap<ArrayList<Byte>, BigInteger>();
            for (int r = 0; r <= maxNode; r++) {
                for (int j = 0; j <= d; j++) {
                    for (byte[] beta : parArr.get(j)) {
                        BigInteger lastN = BigInteger.valueOf(-1); 
                        // parArr is generated by lexicographic order
                        for (byte[] alpha : parArr.get(d - j)) {
                            BigInteger ansN = N(d, r, alpha, beta);
                            curMap.put(Key.make(r, alpha, beta), ansN);
                            if (lastN.compareTo(ansN) < 0 &&
                                lastN.compareTo(BigInteger.ZERO) >= 0) {
                                System.out.format("N(%d, %d, %s, %s) > %d\n",
                                    d, r, MyF.str(alpha), MyF.str(beta), lastN);
                            }
                            lastN = ansN;
                        }
                    }    
                }                       
            } 
        }       
    }    
    /** 
     * The recursive formula is implemented here. 
     */
    private BigInteger N(int d, int r, byte[] alpha, byte[] beta) {  
        //invalid inputs
        if (arrOp.I(alpha) + arrOp.I(beta) != d) {
            System.out.format("I(%s) + I(%s) must equal to %d\n", 
                               MyF.str(alpha), MyF.str(beta), d);
            return BigInteger.ZERO; 
        }    
        if (d <= 0) {
            System.out.format("Degree should be positive: " + d);
            return BigInteger.ZERO;
        }
        if (r < 0) {
            System.out.format("The number of nodes can't be negative: " + r);
            return BigInteger.ZERO;
        }
        if (d == 1 && r == 0 ) return BigInteger.ONE;
        if (d == 1 && r != 0 ) return BigInteger.ZERO;
        
        BigInteger ans = BigInteger.ZERO;  
        // the first term
        for (int k = 0; k < deg; k++) { 
            if (beta[k] > 0) {
                ans = ans.add(first(d, r, alpha, beta, k));
            }
        }    
        // the second term
        for (int j = Math.max(0, arrOp.sum(beta) - r + d - 1); j < d; j++) {
            for (byte[] bP : parArr.get(j)) {
                for (byte[] aP : parArr.get(d - 1 - j)) {
                    ans = ans.add(second(d, r, alpha, beta, aP, bP));
                }                
            }
        }    
        return ans;                                     
    }  
    /** 
     * Computes a single term in the first term
     */
    private BigInteger first(int d, int r, byte[] alpha, byte[] beta, 
                                int k) {            
        byte[] tempAlpha = alpha.clone();
        byte[] tempBeta = beta.clone();
        //alpha_+e_k, beta-e_k
        tempAlpha[k] = (byte) (alpha[k] + 1);  
        tempBeta[k] = (byte) (beta[k] - 1);    
        ArrayList<Byte> key = Key.make(r, tempAlpha, tempBeta);
        if (curMap.containsKey(key)) {
            return curMap.get(key).multiply(BigInteger.valueOf(k + 1));
        }
        else {
            System.out.format("Finding N(%d, %d, %s, %s)\n", 
                d, r, MyF.str(alpha), MyF.str(beta));
            System.out.format("N(%d, %d, %s, %s) can't be found.\n", 
                d, r, MyF.str(tempAlpha), MyF.str(tempBeta));
        }
        return BigInteger.ZERO;  
    }       
    /** 
     *  Computes a single term in the second term
     */
    private BigInteger second(int d, int r, byte[] alpha, byte[] beta, 
                      byte[] aP, byte[] bP) {
        if (arrOp.greater(alpha, aP) && arrOp.greater(bP, beta)) {
            byte[] gamma = arrOp.substract(bP, beta);
            int rP = r + arrOp.sum(gamma) - d + 1;
            // no need to check rP <= maxNode since 
            // r + |gamma| - d + 1 <= maxNode + |bP| -d + 1
            if (rP >= 0) {                
                ArrayList<Byte> key = Key.make(rP, aP, bP);
                if (prevMap.containsKey(key)) {
                    BigInteger coeff = MyF.prod(arrOp.J(gamma),  
                         arrOp.binom(alpha, aP), arrOp.binom(bP, beta));
                    return coeff.multiply(prevMap.get(key));
                }
                else { // Table doesn't contain this term
                    System.out.format("Finding N(%d, %d, %s, %s)\n", 
                        d, r, MyF.str(alpha), MyF.str(beta));
                    System.out.format("N(%d, %d, %s, %s) not found.\n", 
                        d - 1, rP, MyF.str(aP), MyF.str(bP));
                }              
            }
        }
        return BigInteger.ZERO;
    }      
}

